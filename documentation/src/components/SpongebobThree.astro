---
---
<div id="three-spongebob-container" style="position: relative; width: 100%; height: 600px; background: #222; border-radius: 8px; overflow: hidden;">
    <div id="three-canvas-root" style="width: 100%; height: 100%;"></div>
    
    <div id="controls-overlay" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; color: white; font-family: monospace; max-height: 90%; overflow-y: auto;">
        <h4 style="margin: 0 0 10px 0; color: #ffeb3b;">M치trix Traf칩</h4>
        
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;">
             <!-- Row 1 -->
             <div class="input-group"> <input type="number" id="m00" step="0.1" value="1"> </div>
             <div class="input-group"> <input type="number" id="m01" step="0.1" value="0"> </div>
             <div class="input-group"> <input type="number" id="m02" step="0.1" value="0"> </div>
             <!-- Row 2 -->
             <div class="input-group"> <input type="number" id="m10" step="0.1" value="0"> </div>
             <div class="input-group"> <input type="number" id="m11" step="0.1" value="1"> </div>
             <div class="input-group"> <input type="number" id="m12" step="0.1" value="0"> </div>
             <!-- Row 3 -->
             <div class="input-group"> <input type="number" id="m20" step="0.1" value="0"> </div>
             <div class="input-group"> <input type="number" id="m21" step="0.1" value="0"> </div>
             <div class="input-group"> <input type="number" id="m22" step="0.1" value="1"> </div>
        </div>

        <div style="margin-top: 10px; display: flex; gap: 5px;">
            <button id="btn-random">Random</button>
            <button id="btn-reset">Reset</button>
        </div>
        
        <div style="margin-top: 10px;">
           <label><input type="checkbox" id="chk-auto"> Anim치l치s (Auto)</label>
        </div>

        <div style="margin-top: 10px;">
             <button id="btn-fullscreen" style="width: 100%; background: #007bff;">Full Screen</button>
        </div>
        
        <div id="loading-indicator" style="margin-top: 10px; color: #aaa;">Loading Model...</div>
    </div>
</div>

<script>
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';

    // DOM Elements
    const wrapperContainer = document.getElementById('three-spongebob-container');
    const container = document.getElementById('three-canvas-root');
    const loadingInd = document.getElementById('loading-indicator');
    
    // Helper to get input safely
    const getInput = (id) => document.getElementById(id) as HTMLInputElement;

    const inputs = [
        ['m00', 'm01', 'm02'],
        ['m10', 'm11', 'm12'],
        ['m20', 'm21', 'm22']
    ].map(row => row.map(id => getInput(id)));

    const btnRandom = document.getElementById('btn-random');
    const btnReset = document.getElementById('btn-reset');
    const btnFullscreen = document.getElementById('btn-fullscreen');
    const chkAuto = document.getElementById('chk-auto') as HTMLInputElement;

    if (!container || !loadingInd || !btnRandom || !btnReset || !chkAuto || !wrapperContainer || !btnFullscreen) {
        console.error("Critical elements missing");
        // We do not throw here to avoid stopping other scripts if something is partial
    }

    // State
    const state = {
        matrix: [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ],
        targetMatrix: [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ]
    };

    // Three Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 200);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0,0,0);

    // Light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);

    // Axes Helper
    const axesHelper = new THREE.AxesHelper(100);
    scene.add(axesHelper);

    // Load Model
    // @ts-ignore
    let spongeGroup = null;
    const loader = new ThreeMFLoader();
    loader.load('/3D_spongebob.3mf', (group) => {
        
        // Center the geometry
        const box = new THREE.Box3().setFromObject(group);
        const center = box.getCenter(new THREE.Vector3());
        
        // Adjust hierarchy to center it but allow matrix transform
        // We wrap it in a parent object which we will transform
        const wrapper = new THREE.Group();
        
        // Move group so its center is at 0,0,0
        console.log("Centering model at", center);
        group.position.sub(center);
        
        // Scale it up/down to be visible
        // Check size
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 80 / (maxDim || 1);  // Increased scale slightly
        group.scale.set(scale, scale, scale);
        
        // Apply materials if needed, usually 3mf has colors
        // @ts-ignore
        group.traverse((child) => {
             if (child instanceof THREE.Mesh) {
                 // child.material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                 // keep original material if possible
             }
        });

        wrapper.add(group);
        scene.add(wrapper);
        spongeGroup = wrapper; // We control the wrapper
        // @ts-ignore
        spongeGroup.matrixAutoUpdate = false; // We will manually update matrix
        
        loadingInd.textContent = "Model Loaded!";
        loadingInd.style.color = "#4caf50";
        setTimeout(() => { loadingInd.style.display = 'none'; }, 2000);
        
    }, undefined, (err) => {
        console.error(err);
        loadingInd.textContent = "Error loading 3MF file (check /public/3D_spongebob.3mf)";
        loadingInd.style.color = "red";
    });

    // Animation Loop
    // @ts-ignore
    function animate(time) {
        requestAnimationFrame(animate);
        
        const t = time * 0.001;
        
        if (chkAuto && chkAuto.checked) {
             // Auto animate target values
             // Use simple sine waves for demo
             inputs[0][0].value = (1 + Math.sin(t) * 0.5).toFixed(2);
             inputs[0][1].value = (Math.cos(t * 1.3) * 0.5).toFixed(2);
             
             inputs[1][1].value = (1 + Math.cos(t * 0.8) * 0.5).toFixed(2);
             inputs[1][0].value = (Math.sin(t * 1.1) * 0.5).toFixed(2);
             
             updateTargetFromInputs();
        }

        // Smooth state interpolation
        // @ts-ignore
        for(let i=0; i<9; i++) {
            // @ts-ignore
            state.matrix[i] += (state.targetMatrix[i] - state.matrix[i]) * 0.1;
        }

        // Apply matrix to object
        if (spongeGroup) {
            // Mapping 3x3 to 4x4
            // Three.js Matrix4 set takes (n11, n12, n13, n14, ...)
            const m = state.matrix;
            const mat4 = new THREE.Matrix4();
            
            // Note: inputs are [row][col]
            // m array is flat row-major
            
            // @ts-ignore
            mat4.set(
                m[0], m[1], m[2], 0,
                m[3], m[4], m[5], 0,
                m[6], m[7], m[8], 0,
                0,    0,    0,    1
            );
            
            // @ts-ignore
            spongeGroup.matrix.copy(mat4);
            // @ts-ignore
            spongeGroup.updateMatrixWorld(true);
        }

        controls.update();
        renderer.render(scene, camera);
    }
    
    // logic
    function updateTargetFromInputs() {
        // Read 3x3
        let idx = 0;
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                // @ts-ignore
                state.targetMatrix[idx++] = parseFloat(inputs[r][c].value) || 0;
            }
        }
    }

    // Events
    inputs.flat().forEach(input => {
        input.addEventListener('input', updateTargetFromInputs);
    });
    
    // @ts-ignore
    btnRandom.addEventListener('click', () => {
        inputs.flat().forEach(input => {
             // Keep diagonal close to 1, others close to 0
             // But random
             if (Math.random() > 0.5) return; // sometimes keep current
             input.value = (Math.random() * 2 - 1).toFixed(2);
        });
        // Ensure some sanity
        inputs[0][0].value = (Math.random()+0.5).toFixed(2);
        inputs[1][1].value = (Math.random()+0.5).toFixed(2);
        inputs[2][2].value = (Math.random()+0.5).toFixed(2);
        
        updateTargetFromInputs();
    });
    
    // @ts-ignore
    btnReset.addEventListener('click', () => {
        // @ts-ignore
        chkAuto.checked = false;
        
        // Identity
        const identity = [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ];
        
        let idx = 0;
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                inputs[r][c].value = identity[idx++].toString();
            }
        }
        updateTargetFromInputs();
    });

    // @ts-ignore
    btnFullscreen.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            // @ts-ignore
            wrapperContainer.requestFullscreen().catch(err => {
                alert(`Error attempting to enable fullscreen mode: ${err.message} (${err.name})`);
            });
        } else {
            document.exitFullscreen();
        }
    });

    // Handle Resize
    const resizeObserver = new ResizeObserver(() => {
        if(container && container.clientWidth > 0 && container.clientHeight > 0) {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
    });
    // @ts-ignore
    resizeObserver.observe(wrapperContainer); // Observe wrapper for fullscreen changes

    animate(0);

</script>

<style>
    .input-group input {
        width: 100%;
        background: #333;
        border: 1px solid #555;
        color: white;
        text-align: center;
        padding: 4px;
        border-radius: 4px;
    }
    button {
        cursor: pointer;
        padding: 5px 10px;
        background: #444;
        border: none;
        color: white;
        border-radius: 4px;
    }
    button:hover {
        background: #555;
    }
</style>
